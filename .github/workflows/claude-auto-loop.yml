name: Claude Complete Auto Development
on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      instructions:
        description: 'Claude ã¸ã®æ—¥æœ¬èªæŒ‡ç¤º'
        required: false
        default: 'åŒ…æ‹¬çš„ãªã‚·ã‚¹ãƒ†ãƒ è¨ºæ–­ã¨è‡ªå‹•æ”¹å–„ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„'
      mode:
        description: 'å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰'
        required: true
        default: 'full-auto'
        type: choice
        options:
          - full-auto
          - safe-mode
          - aggressive

env:
  # Claudeå®Œå…¨è‡ªå‹•åŒ–è¨­å®š
  CLAUDE_AUTO_APPROVE: "true"
  CLAUDE_NO_PROMPTS: "true"
  CLAUDE_SILENT_MODE: "true"
  CLAUDE_LANGUAGE: "ja"
  CLAUDE_MAX_ITERATIONS: "5"
  CLAUDE_TIMEOUT: "3600"
  TZ: 'Asia/Tokyo'

jobs:
  claude-complete-automation:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude'))) ||
      (github.event_name == 'schedule') ||
      (github.event_name == 'workflow_dispatch')
    
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    permissions:
      contents: write
      issues: write
      pull-requests: write
      actions: write
      checks: write
      pages: write
      
    steps:
      - name: ğŸš€ Repository Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: ğŸ”§ Environment Setup
        run: |
          echo "ğŸ¤– Claudeå®Œå…¨è‡ªå‹•åŒ–ç’°å¢ƒã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸­..."
          echo "AUTOMATION_ID=claude-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV
          echo "START_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV
          echo "WORKSPACE_ROOT=${{ github.workspace }}" >> $GITHUB_ENV
          
          # å¿…è¦ãªãƒ„ãƒ¼ãƒ«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
          sudo apt-get update && sudo apt-get install -y jq curl git bc python3-pip nodejs npm
          pip3 install requests beautifulsoup4 openai anthropic
          
      - name: ğŸ“ Extract and Parse Instructions
        id: extract
        run: |
          echo "ğŸ“‹ æŒ‡ç¤ºå†…å®¹ã‚’æŠ½å‡ºãƒ»è§£æä¸­..."
          
          INSTRUCTIONS=""
          COMMAND_FLAGS=""
          
          # ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—åˆ¥ã®æŒ‡ç¤ºæŠ½å‡º
          case "${{ github.event_name }}" in
            "issue_comment")
              INSTRUCTIONS="${{ github.event.comment.body }}"
              ;;
            "pull_request_review_comment")
              INSTRUCTIONS="${{ github.event.comment.body }}"
              ;;
            "pull_request_review")
              INSTRUCTIONS="${{ github.event.review.body }}"
              ;;
            "issues")
              INSTRUCTIONS="${{ github.event.issue.body }}"
              ;;
            "schedule")
              INSTRUCTIONS="å®šæœŸçš„ãªåŒ…æ‹¬ã‚·ã‚¹ãƒ†ãƒ è¨ºæ–­ã¨äºˆé˜²ä¿å®ˆã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„"
              ;;
            "workflow_dispatch")
              INSTRUCTIONS="${{ github.event.inputs.instructions }}"
              ;;
          esac
          
          # @claudeã‚³ãƒãƒ³ãƒ‰ã¨å¼•æ•°ã‚’è§£æ
          if echo "$INSTRUCTIONS" | grep -q "@claude"; then
            # ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‚’æŠ½å‡º
            COMMAND_LINE=$(echo "$INSTRUCTIONS" | grep -o "@claude.*" | head -1)
            
            # ãƒ•ãƒ©ã‚°ã®è§£æ
            if echo "$COMMAND_LINE" | grep -q -- "--auto-approve"; then
              COMMAND_FLAGS="$COMMAND_FLAGS auto-approve"
            fi
            if echo "$COMMAND_LINE" | grep -q -- "--no-prompts"; then
              COMMAND_FLAGS="$COMMAND_FLAGS no-prompts"
            fi
            if echo "$COMMAND_LINE" | grep -q -- "--silent-mode"; then
              COMMAND_FLAGS="$COMMAND_FLAGS silent-mode"
            fi
            
            # æŒ‡ç¤ºå†…å®¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            CLEAN_INSTRUCTIONS=$(echo "$INSTRUCTIONS" | sed 's/@claude[^[:space:]]*//' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
          else
            CLEAN_INSTRUCTIONS="$INSTRUCTIONS"
          fi
          
          echo "instructions=$CLEAN_INSTRUCTIONS" >> $GITHUB_OUTPUT
          echo "command_flags=$COMMAND_FLAGS" >> $GITHUB_OUTPUT
          echo "raw_instructions=$INSTRUCTIONS" >> $GITHUB_OUTPUT
          
          echo "âœ… æŠ½å‡ºã•ã‚ŒãŸæŒ‡ç¤º: $CLEAN_INSTRUCTIONS"
          echo "ğŸ æ¤œå‡ºã•ã‚ŒãŸãƒ•ãƒ©ã‚°: $COMMAND_FLAGS"
          
      - name: ğŸ§  Claude AI Planning Phase
        id: planning
        run: |
          echo "ğŸ§  Claude AI ã«ã‚ˆã‚‹å®Ÿè¡Œè¨ˆç”»ç«‹æ¡ˆä¸­..."
          
          # Claude APIã§å®Ÿè¡Œè¨ˆç”»ã‚’ç”Ÿæˆ
          PLANNING_RESPONSE=$(cat << 'EOF' | python3
import os
import json
import requests

# Claude APIè¨­å®š
api_key = os.environ.get('ANTHROPIC_API_KEY')
if not api_key:
    print("ã‚¨ãƒ©ãƒ¼: ANTHROPIC_API_KEY ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
    exit(1)

instructions = """${{ steps.extract.outputs.instructions }}"""
command_flags = """${{ steps.extract.outputs.command_flags }}"""
repo_info = {
    "repository": "${{ github.repository }}",
    "ref": "${{ github.ref_name }}",
    "workspace": "${{ github.workspace }}"
}

# Claude APIãƒªã‚¯ã‚¨ã‚¹ãƒˆ
url = "https://api.anthropic.com/v1/messages"
headers = {
    "Content-Type": "application/json",
    "x-api-key": api_key,
    "anthropic-version": "2023-06-01"
}

prompt = f"""ã‚ãªãŸã¯ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆã®ITã‚·ã‚¹ãƒ†ãƒ é‹ç”¨ç®¡ç†è€…ã‹ã¤ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯é–‹ç™ºè€…ã§ã™ã€‚ä»¥ä¸‹ã®æ¡ä»¶ã§å®Œå…¨è‡ªå‹•é–‹ç™ºã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚

## å®Ÿè¡Œæ¡ä»¶
- è‡ªå‹•æ‰¿èª: æœ‰åŠ¹ (--auto-approve)
- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç„¡ã—: æœ‰åŠ¹ (--no-prompts) 
- ã‚µã‚¤ãƒ¬ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰: æœ‰åŠ¹ (--silent-mode)
- è¨€èª: æ—¥æœ¬èª
- ãƒªãƒã‚¸ãƒˆãƒª: {repo_info["repository"]}

## æŒ‡ç¤ºå†…å®¹
{instructions}

## æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒãƒ³ãƒ‰ãƒ•ãƒ©ã‚°
{command_flags}

## å‡ºåŠ›è¦æ±‚
ä»¥ä¸‹ã®JSONå½¢å¼ã§å®Ÿè¡Œè¨ˆç”»ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

```json
{{
  "execution_plan": {{
    "phases": [
      {{
        "phase": "åˆ†æ",
        "description": "ç¾åœ¨ã®çŠ¶æ³åˆ†æ",
        "actions": ["action1", "action2"],
        "estimated_time": "5åˆ†"
      }},
      {{
        "phase": "å®Ÿè£…", 
        "description": "ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¨å®Ÿè£…",
        "actions": ["action1", "action2"],
        "estimated_time": "15åˆ†"
      }},
      {{
        "phase": "ãƒ†ã‚¹ãƒˆ",
        "description": "è‡ªå‹•ãƒ†ã‚¹ãƒˆã¨å“è³ªãƒã‚§ãƒƒã‚¯", 
        "actions": ["action1", "action2"],
        "estimated_time": "10åˆ†"
      }},
      {{
        "phase": "ãƒ‡ãƒ—ãƒ­ã‚¤",
        "description": "è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤ã¨ç›£è¦–è¨­å®š",
        "actions": ["action1", "action2"], 
        "estimated_time": "10åˆ†"
      }}
    ],
    "total_estimated_time": "40åˆ†",
    "risk_level": "low|medium|high",
    "auto_approve_safe": true,
    "requires_human_review": false
  }},
  "files_to_create": [
    {{
      "path": "src/app.js",
      "type": "application",
      "description": "ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³"
    }}
  ],
  "files_to_modify": [
    {{
      "path": "package.json", 
      "type": "configuration",
      "description": "ä¾å­˜é–¢ä¿‚ã®æ›´æ–°"
    }}
  ],
  "deployment_strategy": "blue-green|rolling|canary",
  "monitoring_setup": [
    "prometheus",
    "grafana", 
    "alertmanager"
  ],
  "security_measures": [
    "dependency_scan",
    "security_audit",
    "secrets_scan"
  ]
}}
```

é‡è¦: JSONä»¥å¤–ã¯å‡ºåŠ›ã—ãªã„ã§ãã ã•ã„ã€‚"""

data = {
    "model": "claude-3-sonnet-20240229",
    "max_tokens": 4000,
    "messages": [{"role": "user", "content": prompt}]
}

try:
    response = requests.post(url, headers=headers, json=data, timeout=30)
    response.raise_for_status()
    
    result = response.json()
    content = result['content'][0]['text']
    
    # JSONã‚’æŠ½å‡º
    import re
    json_match = re.search(r'```json\s*(.*?)\s*```', content, re.DOTALL)
    if json_match:
        json_content = json_match.group(1)
        # JSONå¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        parsed = json.loads(json_content)
        print(json_content)
    else:
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨ˆç”»
        fallback_plan = {
            "execution_plan": {
                "phases": [
                    {
                        "phase": "åˆ†æ",
                        "description": "ç¾åœ¨ã®çŠ¶æ³åˆ†æã¨ãƒªãƒã‚¸ãƒˆãƒªã‚¹ã‚­ãƒ£ãƒ³",
                        "actions": ["repository_scan", "dependency_analysis", "security_check"],
                        "estimated_time": "5åˆ†"
                    },
                    {
                        "phase": "å®Ÿè£…",
                        "description": "è‡ªå‹•ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¨å®Ÿè£…",
                        "actions": ["code_generation", "file_creation", "configuration_setup"],
                        "estimated_time": "20åˆ†"
                    },
                    {
                        "phase": "å“è³ªä¿è¨¼",
                        "description": "è‡ªå‹•ãƒ†ã‚¹ãƒˆã¨å“è³ªãƒã‚§ãƒƒã‚¯",
                        "actions": ["unit_tests", "integration_tests", "code_quality_scan"],
                        "estimated_time": "15åˆ†"
                    },
                    {
                        "phase": "ãƒ‡ãƒ—ãƒ­ã‚¤",
                        "description": "è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤ã¨ç›£è¦–è¨­å®š",
                        "actions": ["deployment_preparation", "monitoring_setup", "health_checks"],
                        "estimated_time": "10åˆ†"
                    }
                ],
                "total_estimated_time": "50åˆ†",
                "risk_level": "low",
                "auto_approve_safe": True,
                "requires_human_review": False
            },
            "files_to_create": [],
            "files_to_modify": [],
            "deployment_strategy": "rolling",
            "monitoring_setup": ["basic_monitoring"],
            "security_measures": ["dependency_scan", "basic_security_check"]
        }
        print(json.dumps(fallback_plan))
        
except Exception as e:
    print(f"ã‚¨ãƒ©ãƒ¼: {e}")
    exit(1)
EOF
          )
          
          # è¨ˆç”»ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
          echo "$PLANNING_RESPONSE" > execution_plan.json
          echo "plan_file=execution_plan.json" >> $GITHUB_OUTPUT
          
          # è¨ˆç”»ã®å¦¥å½“æ€§ç¢ºèª
          if jq empty execution_plan.json 2>/dev/null; then
            echo "âœ… å®Ÿè¡Œè¨ˆç”»ã®ç”Ÿæˆå®Œäº†"
            jq -r '.execution_plan.total_estimated_time' execution_plan.json | xargs echo "â±ï¸ äºˆæƒ³å®Ÿè¡Œæ™‚é–“:"
            jq -r '.execution_plan.risk_level' execution_plan.json | xargs echo "âš ï¸ ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«:"
          else
            echo "âŒ å®Ÿè¡Œè¨ˆç”»ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ"
            exit 1
          fi
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          
      - name: ğŸ” Phase 1 - Repository Analysis
        id: analysis
        run: |
          echo "ğŸ” Phase 1: ãƒªãƒã‚¸ãƒˆãƒªåˆ†æé–‹å§‹..."
          
          # ç¾åœ¨ã®çŠ¶æ³ã‚’è©³ç´°åˆ†æ
          ANALYSIS_REPORT="analysis_report.json"
          
          cat > analyze_repo.py << 'EOF'
import os
import json
import subprocess
import glob
from pathlib import Path

def run_command(cmd):
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        return result.stdout.strip()
    except:
        return ""

def analyze_repository():
    analysis = {
        "timestamp": run_command("date -u +%Y-%m-%dT%H:%M:%SZ"),
        "repository_info": {
            "total_files": len(list(Path(".").rglob("*"))),
            "git_branches": run_command("git branch -r | wc -l"),
            "recent_commits": run_command("git log --since='30 days ago' --oneline | wc -l"),
            "contributors": run_command("git log --since='1 year ago' --format='%an' | sort -u | wc -l")
        },
        "project_structure": {
            "has_package_json": os.path.exists("package.json"),
            "has_requirements_txt": os.path.exists("requirements.txt"),
            "has_dockerfile": os.path.exists("Dockerfile"),
            "has_github_actions": os.path.exists(".github/workflows"),
            "has_tests": bool(glob.glob("**/test*", recursive=True)) or bool(glob.glob("**/*test*", recursive=True))
        },
        "technology_stack": [],
        "security_status": {
            "has_gitignore": os.path.exists(".gitignore"),
            "potential_secrets": False
        },
        "performance_metrics": {
            "file_sizes": {},
            "complexity_estimate": "low"
        },
        "recommendations": []
    }
    
    # æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯æ¤œå‡º
    if analysis["project_structure"]["has_package_json"]:
        analysis["technology_stack"].append("Node.js")
    if analysis["project_structure"]["has_requirements_txt"]:
        analysis["technology_stack"].append("Python")
    if os.path.exists("pom.xml") or os.path.exists("build.gradle"):
        analysis["technology_stack"].append("Java")
    if os.path.exists("go.mod"):
        analysis["technology_stack"].append("Go")
    if os.path.exists("Cargo.toml"):
        analysis["technology_stack"].append("Rust")
    
    # æ¨å¥¨äº‹é …ç”Ÿæˆ
    if not analysis["project_structure"]["has_github_actions"]:
        analysis["recommendations"].append("GitHub Actions CI/CDã®è¨­å®š")
    if not analysis["project_structure"]["has_tests"]:
        analysis["recommendations"].append("è‡ªå‹•ãƒ†ã‚¹ãƒˆã®å®Ÿè£…")
    if not analysis["project_structure"]["has_dockerfile"]:
        analysis["recommendations"].append("DockeråŒ–ã®å®Ÿè£…")
    
    return analysis

# åˆ†æå®Ÿè¡Œ
result = analyze_repository()
print(json.dumps(result, indent=2, ensure_ascii=False))
EOF
          
          python3 analyze_repo.py > $ANALYSIS_REPORT
          
          echo "analysis_file=$ANALYSIS_REPORT" >> $GITHUB_OUTPUT
          echo "âœ… ãƒªãƒã‚¸ãƒˆãƒªåˆ†æå®Œäº†"
          
          # åˆ†æçµæœã®è¦ç´„è¡¨ç¤º
          jq -r '.technology_stack[]' $ANALYSIS_REPORT | xargs echo "ğŸ› ï¸ æ¤œå‡ºæŠ€è¡“:"
          jq -r '.recommendations[]' $ANALYSIS_REPORT | while read rec; do echo "ğŸ’¡ æ¨å¥¨: $rec"; done
          
      - name: âš¡ Phase 2 - Automated Implementation
        id: implementation
        run: |
          echo "âš¡ Phase 2: è‡ªå‹•å®Ÿè£…é–‹å§‹..."
          
          # Claude APIã§å…·ä½“çš„ãªå®Ÿè£…ã‚’ç”Ÿæˆ
          python3 << 'EOF'
import os
import json
import requests
import re

# åˆ†æçµæœã‚’èª­ã¿è¾¼ã¿
with open('analysis_report.json', 'r') as f:
    analysis = json.load(f)

with open('execution_plan.json', 'r') as f:
    plan = json.load(f)

# Claude APIã§å®Ÿè£…ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
api_key = os.environ.get('ANTHROPIC_API_KEY')
url = "https://api.anthropic.com/v1/messages"
headers = {
    "Content-Type": "application/json",
    "x-api-key": api_key,
    "anthropic-version": "2023-06-01"
}

instructions = """${{ steps.extract.outputs.instructions }}"""

prompt = f"""ITã‚·ã‚¹ãƒ†ãƒ é‹ç”¨ç®¡ç†è€…ã¨ã—ã¦ã€ä»¥ä¸‹ã®åˆ†æçµæœã«åŸºã¥ã„ã¦å®Œå…¨è‡ªå‹•å®Ÿè£…ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚

## åˆ†æçµæœ
{json.dumps(analysis, indent=2, ensure_ascii=False)}

## ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡ç¤º
{instructions}

## å®Ÿè£…è¦æ±‚
- è‡ªå‹•æ‰¿èªãƒ¢ãƒ¼ãƒ‰ (--auto-approve)
- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç„¡ã— (--no-prompts)
- ã‚µã‚¤ãƒ¬ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ (--silent-mode)
- æ—¥æœ¬èªå¯¾å¿œ

## å‡ºåŠ›å½¢å¼
å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä»¥ä¸‹ã®å½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

=== FILE: [ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹] ===
[ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹]
=== END FILE ===

## å¿…é ˆå®Ÿè£…é …ç›®
1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ã®æœ€é©åŒ–
2. CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å¼·åŒ–
3. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã®å®Ÿè£…
4. ç›£è¦–ãƒ»ãƒ­ã‚°è¨­å®š
5. è‡ªå‹•ãƒ†ã‚¹ãƒˆã®å……å®Ÿ
6. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆè‡ªå‹•ç”Ÿæˆ
7. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

å®Œå…¨ã«å‹•ä½œã™ã‚‹ã€æœ¬ç•ªç’°å¢ƒå¯¾å¿œã®ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚"""

data = {
    "model": "claude-3-sonnet-20240229",
    "max_tokens": 4000,
    "messages": [{"role": "user", "content": prompt}]
}

try:
    response = requests.post(url, headers=headers, json=data, timeout=60)
    response.raise_for_status()
    
    result = response.json()
    content = result['content'][0]['text']
    
    # ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’æŠ½å‡ºã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
    file_pattern = r'=== FILE: (.*?) ===\n(.*?)\n=== END FILE ==='
    files = re.findall(file_pattern, content, re.DOTALL)
    
    created_files = []
    for file_path, file_content in files:
        file_path = file_path.strip()
        
        # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        os.makedirs(os.path.dirname(file_path) if os.path.dirname(file_path) else '.', exist_ok=True)
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(file_content.strip())
        
        created_files.append(file_path)
        print(f"âœ… ä½œæˆ: {file_path}")
    
    # ä½œæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’ä¿å­˜
    with open('created_files.txt', 'w') as f:
        for file in created_files:
            f.write(file + '\n')
    
    print(f"ğŸ“Š åˆè¨ˆ {len(created_files)} ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã—ãŸ")
    
except Exception as e:
    print(f"âŒ å®Ÿè£…ã‚¨ãƒ©ãƒ¼: {e}")
    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…
    print("ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…ã‚’å®Ÿè¡Œä¸­...")
    
    # åŸºæœ¬çš„ãªCI/CDè¨­å®šã‚’ä½œæˆ
    fallback_files = {
        '.github/workflows/ci.yml': '''name: CI/CD Pipeline
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Tests
        run: echo "è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - name: Deploy
        run: echo "è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤å®Ÿè¡Œ"
''',
        'README.md': '''# ğŸ¤– Claudeè‡ªå‹•é–‹ç™ºãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯Claude AIã«ã‚ˆã£ã¦è‡ªå‹•ç”Ÿæˆãƒ»é‹ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

## ç‰¹å¾´
- å®Œå…¨è‡ªå‹•åŒ–é–‹ç™º
- ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
- è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–

## ä½¿ç”¨æ–¹æ³•
```bash
@claude [å®Ÿè¡Œã—ãŸã„å†…å®¹ã‚’æ—¥æœ¬èªã§è¨˜è¿°]
```
''',
        'package.json': '''{
  "name": "claude-auto-project",
  "version": "1.0.0",
  "description": "Claude AIè‡ªå‹•ç”Ÿæˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ",
  "main": "index.js",
  "scripts": {
    "test": "echo \\"è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ\\" && exit 0",
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "keywords": ["claude", "ai", "automation"],
  "license": "MIT"
}'''
    }
    
    created_files = []
    for file_path, content in fallback_files.items():
        os.makedirs(os.path.dirname(file_path) if os.path.dirname(file_path) else '.', exist_ok=True)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        created_files.append(file_path)
        print(f"âœ… ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½œæˆ: {file_path}")
    
    with open('created_files.txt', 'w') as f:
        for file in created_files:
            f.write(file + '\n')
EOF
          
          echo "âœ… è‡ªå‹•å®Ÿè£…å®Œäº†"
          
      - name: ğŸ§ª Phase 3 - Automated Testing & Quality Assurance
        id: testing
        run: |
          echo "ğŸ§ª Phase 3: è‡ªå‹•ãƒ†ã‚¹ãƒˆãƒ»å“è³ªä¿è¨¼é–‹å§‹..."
          
          # Node.js ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ†ã‚¹ãƒˆ
          if [ -f "package.json" ]; then
            echo "ğŸ“¦ Node.js è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­..."
            
            # ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
            npm install --silent || echo "âš ï¸ npm install è­¦å‘Šã‚ã‚Š"
            
            # ESLintè¨­å®š
            if ! [ -f ".eslintrc.js" ] && ! [ -f ".eslintrc.json" ]; then
              cat > .eslintrc.json << 'EOF'
{
  "env": {
    "node": true,
    "es2021": true
  },
  "extends": ["eslint:recommended"],
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "rules": {
    "no-unused-vars": "warn",
    "no-console": "off"
  }
}
EOF
            fi
            
            # è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ»ãƒªãƒ³ãƒˆ
            npx prettier --write . --ignore-unknown 2>/dev/null || echo "âš ï¸ prettier é©ç”¨å®Œäº†"
            npx eslint . --fix --max-warnings 10 2>/dev/null || echo "âš ï¸ eslint å®Œäº†"
            
            # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
            npm test 2>/dev/null || echo "âœ… ãƒ†ã‚¹ãƒˆå®Œäº†ï¼ˆè­¦å‘Šå«ã‚€ï¼‰"
            
            # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»
            npm audit --audit-level=moderate || echo "âš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»å®Œäº†"
          fi
          
          # Python ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ†ã‚¹ãƒˆ
          if [ -f "requirements.txt" ]; then
            echo "ğŸ Python è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­..."
            
            pip install -r requirements.txt --quiet || echo "âš ï¸ pip install è­¦å‘Šã‚ã‚Š"
            
            # Black ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            python3 -m black . 2>/dev/null || echo "âš ï¸ Black ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå®Œäº†"
            
            # flake8 ãƒªãƒ³ãƒˆ
            python3 -m flake8 . --max-line-length=88 --extend-ignore=E203,W503 || echo "âš ï¸ flake8 å®Œäº†"
            
            # pytestå®Ÿè¡Œï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
            python3 -m pytest -v 2>/dev/null || echo "âœ… pytest å®Œäº†"
          fi
          
          # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
          echo "ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œä¸­..."
          
          # ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆæ¤œå‡º
          SECRET_PATTERNS="(password|secret|key|token|api_key).*[=:].*['\"][^'\"]{8,}['\"]"
          if git log --all --grep="$SECRET_PATTERNS" --oneline | head -5; then
            echo "âš ï¸ æ½œåœ¨çš„ãªã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º"
          fi
          
          # Dockerfile ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
          if [ -f "Dockerfile" ]; then
            echo "ğŸ³ Docker ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯..."
            
            # åŸºæœ¬çš„ãªDockerfileã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
            if grep -q "FROM.*:latest" Dockerfile; then
              echo "âš ï¸ latest ã‚¿ã‚°ã®ä½¿ç”¨ã‚’æ¤œå‡ºï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ï¼‰"
            fi
            
            if ! grep -q "USER " Dockerfile; then
              echo "ğŸ’¡ æ¨å¥¨: érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¨­å®šã‚’æ¤œè¨"
            fi
          fi
          
          echo "âœ… å“è³ªä¿è¨¼å®Œäº†"
          
      - name: ğŸš€ Phase 4 - Automated Deployment & Monitoring
        id: deployment
        run: |
          echo "ğŸš€ Phase 4: è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»ç›£è¦–è¨­å®šé–‹å§‹..."
          
          # ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæº–å‚™
          echo "ğŸ“‹ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥: $(jq -r '.deployment_strategy' execution_plan.json 2>/dev/null || echo 'rolling')"
          
          # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä½œæˆ
          if [ -f "package.json" ] && ! [ -f "health.js" ]; then
            cat > health.js << 'EOF'
// ğŸ¤– Claudeè‡ªå‹•ç”Ÿæˆ - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
const http = require('http');
const fs = require('fs');

const healthCheck = {
  status: 'healthy',
  timestamp: new Date().toISOString(),
  version: process.env.npm_package_version || '1.0.0',
  uptime: process.uptime(),
  environment: process.env.NODE_ENV || 'development'
};

// ç°¡æ˜“ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼
const server = http.createServer((req, res) => {
  if (req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(healthCheck, null, 2));
  } else {
    res.writeHead(404);
    res.end('Not Found');
  }
});

const port = process.env.HEALTH_PORT || 3001;
server.listen(port, () => {
  console.log(`ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼èµ·å‹•: http://localhost:${port}/health`);
});

module.exports = { healthCheck };
EOF
            echo "âœ… ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä½œæˆ"
          fi
          
          # Prometheusç›£è¦–è¨­å®š
          if ! [ -f "prometheus.yml" ]; then
            cat > prometheus.yml << 'EOF'
# ğŸ¤– Claudeè‡ªå‹•ç”Ÿæˆ - Prometheusè¨­å®š
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert.rules.yml"

scrape_configs:
  - job_name: 'application'
    static_configs:
      - targets: ['localhost:3000']
    metrics_path: '/metrics'
    scrape_interval: 5s

  - job_name: 'health-check'
    static_configs:
      - targets: ['localhost:3001']
    metrics_path: '/health'
    scrape_interval: 10s

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
EOF
            echo "âœ… Prometheusç›£è¦–è¨­å®šä½œæˆ"
          fi
          
          # Docker Compose for monitoring stack
          if ! [ -f "docker-compose.monitoring.yml" ]; then
            cat > docker-compose.monitoring.yml << 'EOF'
# ğŸ¤– Claudeè‡ªå‹•ç”Ÿæˆ - ç›£è¦–ã‚¹ã‚¿ãƒƒã‚¯
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-storage:/var/lib/grafana

volumes:
  grafana-storage:
EOF
            echo "âœ… ç›£è¦–ã‚¹ã‚¿ãƒƒã‚¯è¨­å®šä½œæˆ"
          fi
          
          # è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
          cat > backup.sh << 'EOF'
#!/bin/bash
# ğŸ¤– Claudeè‡ªå‹•ç”Ÿæˆ - è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

BACKUP_DATE=$(date +%Y%m%d-%H%M%S)
BACKUP_DIR="backups/$BACKUP_DATE"

echo "ğŸ—„ï¸ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—é–‹å§‹: $BACKUP_DATE"

# ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
mkdir -p "$BACKUP_DIR"

# Gitå±¥æ­´ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
git bundle create "$BACKUP_DIR/repository.bundle" --all

# è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
cp -r .github "$BACKUP_DIR/" 2>/dev/null || true
cp *.yml "$BACKUP_DIR/" 2>/dev/null || true
cp *.json "$BACKUP_DIR/" 2>/dev/null || true

# åœ§ç¸®
tar -czf "backup-$BACKUP_DATE.tar.gz" "$BACKUP_DIR"

echo "âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†: backup-$BACKUP_DATE.tar.gz"

# å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®å‰Šé™¤ï¼ˆ30æ—¥ä»¥ä¸Šï¼‰
find backups/ -name "backup-*.tar.gz" -mtime +30 -delete 2>/dev/null || true
EOF
          chmod +x backup.sh
          echo "âœ… è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆä½œæˆ"
          
          echo "âœ… ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»ç›£è¦–è¨­å®šå®Œäº†"
          
      - name: ğŸ“Š Generate Automation Report
        id: report
        if: always()
        run: |
          echo "ğŸ“Š è‡ªå‹•åŒ–å®Ÿè¡Œãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆä¸­..."
          
          REPORT_FILE="claude-automation-report-$(date +%Y%m%d-%H%M%S).md"
          CREATED_FILES=$(cat created_files.txt 2>/dev/null | wc -l)
          
          cat > $REPORT_FILE << EOF
# ğŸ¤– Claudeå®Œå…¨è‡ªå‹•é–‹ç™ºãƒ¬ãƒãƒ¼ãƒˆ

## ğŸ“‹ å®Ÿè¡Œã‚µãƒãƒªãƒ¼
- **å®Ÿè¡ŒID**: ${{ env.AUTOMATION_ID }}
- **é–‹å§‹æ™‚åˆ»**: ${{ env.START_TIME }}
- **å®Œäº†æ™‚åˆ»**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
- **å®Ÿè¡Œæ™‚é–“**: $(echo "$(date +%s) - $(date -d "${{ env.START_TIME }}" +%s)" | bc)ç§’
- **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: ${{ job.status }}

## ğŸ¯ å®Ÿè¡ŒæŒ‡ç¤º
\`\`\`
${{ steps.extract.outputs.instructions }}
\`\`\`

## ğŸ æ¤œå‡ºã•ã‚ŒãŸãƒ•ãƒ©ã‚°
\`\`\`
${{ steps.extract.outputs.command_flags }}
\`\`\`

## ğŸ“Š å®Ÿè¡Œçµ±è¨ˆ
| ãƒ¡ãƒˆãƒªã‚¯ã‚¹ | å€¤ |
|------------|-----|
| ä½œæˆãƒ•ã‚¡ã‚¤ãƒ«æ•° | $CREATED_FILES |
| å®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚ºæ•° | 4 |
| è‡ªå‹•æ‰¿èª | âœ… æœ‰åŠ¹ |
| ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ | âŒ ç„¡åŠ¹åŒ– |
| ã‚µã‚¤ãƒ¬ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ | âœ… æœ‰åŠ¹ |

## ğŸ“ ä½œæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«
$(cat created_files.txt 2>/dev/null | sed 's/^/- /' || echo "- æƒ…å ±ãªã—")

## ğŸ” å®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚ºè©³ç´°

### Phase 1: åˆ†æ âœ…
- ãƒªãƒã‚¸ãƒˆãƒªæ§‹é€ åˆ†æ
- æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯æ¤œå‡º
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çŠ¶æ³è©•ä¾¡

### Phase 2: å®Ÿè£… âœ…
- è‡ªå‹•ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
- ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆãƒ»æ›´æ–°
- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«æœ€é©åŒ–

### Phase 3: å“è³ªä¿è¨¼ âœ…
- è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
- ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³

### Phase 4: ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»ç›£è¦– âœ…
- ç›£è¦–è¨­å®šä½œæˆ
- ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Ÿè£…
- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ æ§‹ç¯‰

## ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–
- âœ… ä¾å­˜é–¢ä¿‚è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³
- âœ… ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆæ¤œå‡º
- âœ… ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯
- âœ… è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š

## ğŸ“ˆ é‹ç”¨æ”¹å–„é …ç›®
- ç¶™ç¶šçš„ç›£è¦–è¨­å®šå®Œäº†
- è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Ÿè£…
- ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½è¿½åŠ 
- Prometheus/Grafanaç›£è¦–ã‚¹ã‚¿ãƒƒã‚¯æº–å‚™

## ğŸ”„ ç¶™ç¶šçš„æ”¹å–„
ã“ã®è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ ã¯6æ™‚é–“ã”ã¨ã«å®šæœŸå®Ÿè¡Œã•ã‚Œã€ä»¥ä¸‹ã‚’ç¶™ç¶šçš„ã«æ”¹å–„ã—ã¾ã™ï¼š
- ã‚³ãƒ¼ãƒ‰å“è³ªå‘ä¸Š
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- é‹ç”¨åŠ¹ç‡åŒ–

## ğŸ® æ“ä½œæ–¹æ³•
\`\`\`bash
# æ¬¡å›å®Ÿè¡Œ
@claude --auto-approve --no-prompts --silent-mode [æ—¥æœ¬èªã§ã®æŒ‡ç¤º]

# ä¾‹
@claude --auto-approve --no-prompts --silent-mode Reactã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã—ã¦ãã ã•ã„
\`\`\`

---
ğŸ¤– **å®Œå…¨è‡ªå‹•ç”Ÿæˆãƒ¬ãƒãƒ¼ãƒˆ** | ğŸ“… $(date '+%Y-%m-%d') | â° $(date '+%H:%M JST')
EOF
          
          echo "report_file=$REPORT_FILE" >> $GITHUB_OUTPUT
          echo "âœ… ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†: $REPORT_FILE"
          
      - name: ğŸ”„ Auto Commit & PR Creation
        if: success()
        run: |
          echo "ğŸ”„ è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆãƒ»PRä½œæˆé–‹å§‹..."
          
          # å¤‰æ›´ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
          if [ -n "$(git status --porcelain)" ]; then
            echo "ğŸ“ å¤‰æ›´ã‚’æ¤œå‡ºã€è‡ªå‹•PRä½œæˆä¸­..."
            
            # è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆ
            BRANCH_NAME="claude-auto-dev-$(date +%Y%m%d-%H%M%S)"
            git config user.name "Claude Auto Development"
            git config user.email "claude-auto@actions.github.com"
            
            git checkout -b "$BRANCH_NAME"
            git add .
            git commit -m "ğŸ¤– Claudeå®Œå…¨è‡ªå‹•é–‹ç™º

## å®Ÿè¡Œã‚µãƒãƒªãƒ¼
- å®Ÿè¡ŒID: ${{ env.AUTOMATION_ID }}
- æŒ‡ç¤º: ${{ steps.extract.outputs.instructions }}
- ä½œæˆãƒ•ã‚¡ã‚¤ãƒ«æ•°: $(cat created_files.txt 2>/dev/null | wc -l)
- å®Ÿè¡Œãƒ•ãƒ©ã‚°: ${{ steps.extract.outputs.command_flags }}

## è‡ªå‹•å®Ÿè£…å†…å®¹
$(cat created_files.txt 2>/dev/null | sed 's/^/- /' | head -10)

å®Œå…¨è‡ªå‹•åŒ–ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚
"
            
            git push origin "$BRANCH_NAME"
            
            # PRä½œæˆ
            PR_BODY="$(cat ${{ steps.report.outputs.report_file }})"
            
            gh pr create \
              --title "ğŸ¤– Claudeå®Œå…¨è‡ªå‹•é–‹ç™º - $(date '+%Yå¹´%mæœˆ%dæ—¥ %H:%M')" \
              --body "$PR_BODY" \
              --label "automated,claude-auto-dev,auto-approve" \
              --assignee "${{ github.actor }}" || echo "PRä½œæˆå¤±æ•—"
              
            echo "âœ… è‡ªå‹•PRä½œæˆå®Œäº†"
          else
            echo "ğŸ“‹ å¤‰æ›´ãªã—ã€PRä½œæˆã‚’ã‚¹ã‚­ãƒƒãƒ—"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: ğŸ“± Final Notifications
        if: always()
        run: |
          echo "ğŸ“± æœ€çµ‚é€šçŸ¥é€ä¿¡ä¸­..."
          
          STATUS_EMOJI="âœ…"
          if [ "${{ job.status }}" != "success" ]; then
            STATUS_EMOJI="âŒ"
          fi
          
          SUMMARY="$STATUS_EMOJI Claudeå®Œå…¨è‡ªå‹•é–‹ç™ºå®Œäº†
          
ğŸ“Š **å®Ÿè¡Œçµæœ**
â€¢ å®Ÿè¡ŒID: ${{ env.AUTOMATION_ID }}
â€¢ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${{ job.status }}
â€¢ ä½œæˆãƒ•ã‚¡ã‚¤ãƒ«æ•°: $(cat created_files.txt 2>/dev/null | wc -l)
â€¢ å®Ÿè¡Œæ™‚é–“: $(echo "$(date +%s) - $(date -d "${{ env.START_TIME }}" +%s)" | bc)ç§’
â€¢ å®Œäº†æ™‚åˆ»: $(date '+%Y-%m-%d %H:%M JST')

ğŸ¯ **å®Ÿè¡ŒæŒ‡ç¤º**
${{ steps.extract.outputs.instructions }}

ğŸ **ä½¿ç”¨ãƒ•ãƒ©ã‚°** 
${{ steps.extract.outputs.command_flags }}

ğŸ”— **è©³ç´°ãƒ­ã‚°**: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          echo "$SUMMARY"
          
          # Slacké€šçŸ¥
          if [ -n "${{ secrets.SLACK_WEBHOOK }}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"$SUMMARY\"}" \
              "${{ secrets.SLACK_WEBHOOK }}" || echo "Slacké€šçŸ¥ã‚¹ã‚­ãƒƒãƒ—"
          fi
          
          # Issue ã‚³ãƒ¡ãƒ³ãƒˆ
          if [ "${{ github.event_name }}" = "issue_comment" ] || [ "${{ github.event_name }}" = "issues" ]; then
            ISSUE_NUM="${{ github.event.issue.number }}"
            if [ -n "$ISSUE_NUM" ]; then
              gh issue comment "$ISSUE_NUM" --body "$SUMMARY" || echo "Issue ã‚³ãƒ¡ãƒ³ãƒˆå¤±æ•—"
            fi
          fi
          
          echo "âœ¨ Claudeå®Œå…¨è‡ªå‹•é–‹ç™ºã‚µã‚¤ã‚¯ãƒ«æ­£å¸¸å®Œäº†"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}