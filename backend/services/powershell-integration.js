/**
 * Enhanced PowerShell Integration Service for ServiceGrid ITSM
 * Features: Secure script execution, output validation, timeout protection,
 * comprehensive logging, and error handling
 */
const { spawn, exec } = require('child_process');
const path = require('path');
const fs = require('fs').promises;
const crypto = require('crypto');
const {
  ITSMError,
  createValidationError,
  logError,
  generateRequestId
} = require('../utils/errorHandler');
const { logAuditEvent, logSecurityEvent } = require('../middleware/enhanced-security');

// PowerShell configuration
const PS_CONFIG = {
  timeout: parseInt(process.env.PS_TIMEOUT) || 30000, // 30 seconds
  maxOutputSize: parseInt(process.env.PS_MAX_OUTPUT) || 1024 * 1024, // 1MB
  allowedScriptDirs: process.env.PS_ALLOWED_DIRS ? 
    process.env.PS_ALLOWED_DIRS.split(',') : 
    [path.join(__dirname, '..', 'api'), path.join(__dirname, '..', 'scripts')],
  enableLogging: process.env.PS_ENABLE_LOGGING !== 'false',
  sanitizeOutput: process.env.PS_SANITIZE_OUTPUT !== 'false',
  allowedCommands: process.env.PS_ALLOWED_COMMANDS ?
    process.env.PS_ALLOWED_COMMANDS.split(',') :
    ['Get-*', 'Test-*', 'Invoke-*', 'New-*', 'Set-*', 'Remove-*'],
  blockedCommands: process.env.PS_BLOCKED_COMMANDS ?
    process.env.PS_BLOCKED_COMMANDS.split(',') :
    ['Format-*', 'Clear-*', 'Stop-*', 'Restart-*', 'Remove-Computer', 'Remove-ADUser'],
  executionPolicy: process.env.PS_EXECUTION_POLICY || 'RemoteSigned'
};\n\nclass PowerShellIntegration {\n  constructor() {\n    this.activeProcesses = new Map();\n    this.metrics = {\n      totalExecutions: 0,\n      successfulExecutions: 0,\n      failedExecutions: 0,\n      timeoutExecutions: 0,\n      averageExecutionTime: 0,\n      totalExecutionTime: 0,\n      blockedExecutions: 0\n    };\n  }\n\n  /**\n   * Execute PowerShell script with comprehensive security and monitoring\n   */\n  async executeScript(scriptPath, parameters = {}, options = {}) {\n    const executionId = generateRequestId();\n    const startTime = Date.now();\n    \n    try {\n      // Validate script path\n      await this.validateScriptPath(scriptPath);\n      \n      // Validate parameters\n      const sanitizedParams = this.sanitizeParameters(parameters);\n      \n      // Build command\n      const command = await this.buildCommand(scriptPath, sanitizedParams, options);\n      \n      // Log execution start\n      await this.logExecution('SCRIPT_EXECUTION_START', {\n        executionId,\n        scriptPath,\n        parameters: Object.keys(sanitizedParams),\n        command: command.substring(0, 200)\n      }, options.userId, options.username, options.ip);\n      \n      // Execute with timeout\n      const result = await this.executeWithTimeout(command, options);\n      \n      // Validate and sanitize output\n      const sanitizedResult = this.sanitizeOutput(result);\n      \n      // Update metrics\n      const executionTime = Date.now() - startTime;\n      this.updateMetrics(true, executionTime);\n      \n      // Log successful execution\n      await this.logExecution('SCRIPT_EXECUTION_SUCCESS', {\n        executionId,\n        scriptPath,\n        executionTime,\n        outputSize: sanitizedResult.stdout.length\n      }, options.userId, options.username, options.ip);\n      \n      return {\n        success: true,\n        executionId,\n        stdout: sanitizedResult.stdout,\n        stderr: sanitizedResult.stderr,\n        exitCode: sanitizedResult.exitCode,\n        executionTime,\n        timestamp: new Date().toISOString()\n      };\n      \n    } catch (error) {\n      const executionTime = Date.now() - startTime;\n      \n      if (error.message.includes('timeout')) {\n        this.metrics.timeoutExecutions++;\n      }\n      \n      this.updateMetrics(false, executionTime);\n      \n      // Log failed execution\n      await this.logExecution('SCRIPT_EXECUTION_FAILED', {\n        executionId,\n        scriptPath,\n        error: error.message,\n        executionTime\n      }, options.userId, options.username, options.ip);\n      \n      throw new ITSMError(\n        `PowerShell script execution failed: ${error.message}`,\n        'POWERSHELL_ERROR',\n        500,\n        { executionId, scriptPath, error: error.message }\n      );\n    }\n  }\n\n  /**\n   * Execute PowerShell command directly with security checks\n   */\n  async executeCommand(command, options = {}) {\n    const executionId = generateRequestId();\n    const startTime = Date.now();\n    \n    try {\n      // Validate command\n      await this.validateCommand(command);\n      \n      // Build secure command\n      const secureCommand = this.buildSecureCommand(command, options);\n      \n      // Log execution start\n      await this.logExecution('COMMAND_EXECUTION_START', {\n        executionId,\n        command: command.substring(0, 100),\n        secureCommand: secureCommand.substring(0, 100)\n      }, options.userId, options.username, options.ip);\n      \n      // Execute with timeout\n      const result = await this.executeWithTimeout(secureCommand, options);\n      \n      // Validate and sanitize output\n      const sanitizedResult = this.sanitizeOutput(result);\n      \n      // Update metrics\n      const executionTime = Date.now() - startTime;\n      this.updateMetrics(true, executionTime);\n      \n      // Log successful execution\n      await this.logExecution('COMMAND_EXECUTION_SUCCESS', {\n        executionId,\n        command: command.substring(0, 100),\n        executionTime,\n        outputSize: sanitizedResult.stdout.length\n      }, options.userId, options.username, options.ip);\n      \n      return {\n        success: true,\n        executionId,\n        stdout: sanitizedResult.stdout,\n        stderr: sanitizedResult.stderr,\n        exitCode: sanitizedResult.exitCode,\n        executionTime,\n        timestamp: new Date().toISOString()\n      };\n      \n    } catch (error) {\n      const executionTime = Date.now() - startTime;\n      this.updateMetrics(false, executionTime);\n      \n      // Log failed execution\n      await this.logExecution('COMMAND_EXECUTION_FAILED', {\n        executionId,\n        command: command.substring(0, 100),\n        error: error.message,\n        executionTime\n      }, options.userId, options.username, options.ip);\n      \n      throw new ITSMError(\n        `PowerShell command execution failed: ${error.message}`,\n        'POWERSHELL_ERROR',\n        500,\n        { executionId, command, error: error.message }\n      );\n    }\n  }\n\n  /**\n   * Validate script path for security\n   */\n  async validateScriptPath(scriptPath) {\n    // Check if path exists\n    try {\n      await fs.access(scriptPath, fs.constants.R_OK);\n    } catch (error) {\n      throw new ITSMError(\n        'PowerShell script not found or not readable',\n        'POWERSHELL_ERROR',\n        404,\n        { scriptPath }\n      );\n    }\n    \n    // Check if path is in allowed directories\n    const absolutePath = path.resolve(scriptPath);\n    const isAllowed = PS_CONFIG.allowedScriptDirs.some(allowedDir => {\n      const absoluteAllowedDir = path.resolve(allowedDir);\n      return absolutePath.startsWith(absoluteAllowedDir);\n    });\n    \n    if (!isAllowed) {\n      await logSecurityEvent('UNAUTHORIZED_SCRIPT_ACCESS', {\n        scriptPath: absolutePath,\n        allowedDirs: PS_CONFIG.allowedScriptDirs,\n        severity: 'HIGH'\n      });\n      \n      throw new ITSMError(\n        'PowerShell script path not in allowed directories',\n        'POWERSHELL_ERROR',\n        403,\n        { scriptPath, allowedDirs: PS_CONFIG.allowedScriptDirs }\n      );\n    }\n    \n    // Check file extension\n    if (!scriptPath.toLowerCase().endsWith('.ps1')) {\n      throw new ITSMError(\n        'Only PowerShell (.ps1) files are allowed',\n        'POWERSHELL_ERROR',\n        400,\n        { scriptPath }\n      );\n    }\n    \n    return true;\n  }\n\n  /**\n   * Validate PowerShell command for security\n   */\n  async validateCommand(command) {\n    if (!command || typeof command !== 'string') {\n      throw createValidationError('Command must be a non-empty string');\n    }\n    \n    // Check for blocked commands\n    const blockedPattern = new RegExp(\n      PS_CONFIG.blockedCommands\n        .map(cmd => cmd.replace('*', '.*'))\n        .join('|'),\n      'i'\n    );\n    \n    if (blockedPattern.test(command)) {\n      this.metrics.blockedExecutions++;\n      \n      await logSecurityEvent('BLOCKED_POWERSHELL_COMMAND', {\n        command: command.substring(0, 200),\n        blockedCommands: PS_CONFIG.blockedCommands,\n        severity: 'HIGH'\n      });\n      \n      throw new ITSMError(\n        'PowerShell command contains blocked operations',\n        'POWERSHELL_ERROR',\n        403,\n        { command: command.substring(0, 100), blockedCommands: PS_CONFIG.blockedCommands }\n      );\n    }\n    \n    // Check for suspicious patterns\n    const suspiciousPatterns = [\n      /Invoke-Expression/i,\n      /IEX\\s/i,\n      /DownloadString/i,\n      /DownloadFile/i,\n      /BitsTransfer/i,\n      /Start-Process.*-WindowStyle\\s+Hidden/i,\n      /Invoke-WebRequest.*-UseBasicParsing/i,\n      /New-Object.*Net\\.WebClient/i,\n      /\\$env:temp/i,\n      /\\$env:appdata/i,\n      /-EncodedCommand/i,\n      /-WindowStyle\\s+Hidden/i,\n      /-ExecutionPolicy\\s+Bypass/i\n    ];\n    \n    const suspiciousPattern = suspiciousPatterns.find(pattern => pattern.test(command));\n    if (suspiciousPattern) {\n      await logSecurityEvent('SUSPICIOUS_POWERSHELL_COMMAND', {\n        command: command.substring(0, 200),\n        suspiciousPattern: suspiciousPattern.source,\n        severity: 'HIGH'\n      });\n      \n      throw new ITSMError(\n        'PowerShell command contains suspicious patterns',\n        'POWERSHELL_ERROR',\n        403,\n        { command: command.substring(0, 100) }\n      );\n    }\n    \n    return true;\n  }\n\n  /**\n   * Sanitize input parameters\n   */\n  sanitizeParameters(parameters) {\n    const sanitized = {};\n    \n    for (const [key, value] of Object.entries(parameters)) {\n      // Validate parameter name\n      if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(key)) {\n        throw createValidationError(`Invalid parameter name: ${key}`);\n      }\n      \n      // Sanitize parameter value\n      if (typeof value === 'string') {\n        // Remove potentially dangerous characters\n        sanitized[key] = value\n          .replace(/[`;\"'\\$\\{\\}\\[\\]\\(\\)\\|&<>]/g, '')\n          .trim();\n      } else if (typeof value === 'number' || typeof value === 'boolean') {\n        sanitized[key] = value;\n      } else {\n        throw createValidationError(`Invalid parameter type for ${key}: ${typeof value}`);\n      }\n    }\n    \n    return sanitized;\n  }\n\n  /**\n   * Build secure PowerShell command\n   */\n  async buildCommand(scriptPath, parameters, options) {\n    const paramString = Object.entries(parameters)\n      .map(([key, value]) => `-${key} \"${value}\"`)\n      .join(' ');\n    \n    return `powershell.exe -ExecutionPolicy ${PS_CONFIG.executionPolicy} -NoProfile -NonInteractive -File \"${scriptPath}\" ${paramString}`;\n  }\n\n  /**\n   * Build secure command for direct execution\n   */\n  buildSecureCommand(command, options) {\n    return `powershell.exe -ExecutionPolicy ${PS_CONFIG.executionPolicy} -NoProfile -NonInteractive -Command \"& {${command}}\"`;\n  }\n\n  /**\n   * Execute command with timeout protection\n   */\n  async executeWithTimeout(command, options = {}) {\n    const timeout = options.timeout || PS_CONFIG.timeout;\n    const processId = crypto.randomBytes(8).toString('hex');\n    \n    return new Promise((resolve, reject) => {\n      let stdout = '';\n      let stderr = '';\n      let isResolved = false;\n      \n      // Create process\n      const process = spawn('cmd.exe', ['/c', command], {\n        stdio: ['ignore', 'pipe', 'pipe'],\n        shell: false,\n        windowsHide: true\n      });\n      \n      // Track active process\n      this.activeProcesses.set(processId, process);\n      \n      // Set timeout\n      const timeoutHandle = setTimeout(() => {\n        if (!isResolved) {\n          isResolved = true;\n          process.kill('SIGKILL');\n          this.activeProcesses.delete(processId);\n          reject(new Error(`PowerShell execution timeout after ${timeout}ms`));\n        }\n      }, timeout);\n      \n      // Handle stdout\n      process.stdout.on('data', (data) => {\n        stdout += data.toString();\n        \n        // Check output size limit\n        if (stdout.length > PS_CONFIG.maxOutputSize) {\n          if (!isResolved) {\n            isResolved = true;\n            clearTimeout(timeoutHandle);\n            process.kill('SIGKILL');\n            this.activeProcesses.delete(processId);\n            reject(new Error('PowerShell output size limit exceeded'));\n          }\n        }\n      });\n      \n      // Handle stderr\n      process.stderr.on('data', (data) => {\n        stderr += data.toString();\n      });\n      \n      // Handle process completion\n      process.on('close', (code, signal) => {\n        if (!isResolved) {\n          isResolved = true;\n          clearTimeout(timeoutHandle);\n          this.activeProcesses.delete(processId);\n          \n          if (signal === 'SIGKILL') {\n            reject(new Error('PowerShell process was killed'));\n          } else {\n            resolve({\n              stdout,\n              stderr,\n              exitCode: code\n            });\n          }\n        }\n      });\n      \n      // Handle process errors\n      process.on('error', (error) => {\n        if (!isResolved) {\n          isResolved = true;\n          clearTimeout(timeoutHandle);\n          this.activeProcesses.delete(processId);\n          reject(error);\n        }\n      });\n    });\n  }\n\n  /**\n   * Sanitize output for security\n   */\n  sanitizeOutput(result) {\n    if (!PS_CONFIG.sanitizeOutput) {\n      return result;\n    }\n    \n    const sanitizeText = (text) => {\n      if (!text || typeof text !== 'string') {\n        return text;\n      }\n      \n      // Remove potentially sensitive information\n      return text\n        .replace(/password[\\s]*[:=][\\s]*[^\\s\\n\\r]+/gi, 'password: [REDACTED]')\n        .replace(/token[\\s]*[:=][\\s]*[^\\s\\n\\r]+/gi, 'token: [REDACTED]')\n        .replace(/secret[\\s]*[:=][\\s]*[^\\s\\n\\r]+/gi, 'secret: [REDACTED]')\n        .replace(/key[\\s]*[:=][\\s]*[^\\s\\n\\r]+/gi, 'key: [REDACTED]')\n        .replace(/\\$env:[A-Z_]+/gi, '[ENV_VAR]')\n        .trim();\n    };\n    \n    return {\n      stdout: sanitizeText(result.stdout),\n      stderr: sanitizeText(result.stderr),\n      exitCode: result.exitCode\n    };\n  }\n\n  /**\n   * Update execution metrics\n   */\n  updateMetrics(success, executionTime) {\n    this.metrics.totalExecutions++;\n    this.metrics.totalExecutionTime += executionTime;\n    this.metrics.averageExecutionTime = this.metrics.totalExecutionTime / this.metrics.totalExecutions;\n    \n    if (success) {\n      this.metrics.successfulExecutions++;\n    } else {\n      this.metrics.failedExecutions++;\n    }\n  }\n\n  /**\n   * Log execution events\n   */\n  async logExecution(eventType, details, userId, username, ip) {\n    if (!PS_CONFIG.enableLogging) {\n      return;\n    }\n    \n    await logAuditEvent(eventType, {\n      userId,\n      username: username || 'system',\n      ip: ip || 'localhost',\n      details\n    });\n  }\n\n  /**\n   * Get execution metrics\n   */\n  getMetrics() {\n    return {\n      ...this.metrics,\n      activeProcesses: this.activeProcesses.size,\n      successRate: this.metrics.totalExecutions > 0 ?\n        (this.metrics.successfulExecutions / this.metrics.totalExecutions * 100).toFixed(2) + '%' :\n        '0%',\n      config: {\n        timeout: PS_CONFIG.timeout,\n        maxOutputSize: PS_CONFIG.maxOutputSize,\n        allowedScriptDirs: PS_CONFIG.allowedScriptDirs.length,\n        blockedCommands: PS_CONFIG.blockedCommands.length\n      }\n    };\n  }\n\n  /**\n   * Kill all active processes (for shutdown)\n   */\n  async killAllProcesses() {\n    const promises = [];\n    \n    for (const [processId, process] of this.activeProcesses.entries()) {\n      promises.push(new Promise((resolve) => {\n        process.kill('SIGKILL');\n        setTimeout(resolve, 1000); // Give process time to die\n      }));\n    }\n    \n    await Promise.all(promises);\n    this.activeProcesses.clear();\n    \n    console.log('All PowerShell processes terminated');\n  }\n\n  /**\n   * Test PowerShell availability\n   */\n  async testAvailability() {\n    try {\n      const result = await this.executeCommand('Get-Host | Select-Object Version', {\n        timeout: 5000\n      });\n      \n      return {\n        available: true,\n        version: result.stdout.trim(),\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      return {\n        available: false,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n}\n\n// Singleton instance\nconst powerShellIntegration = new PowerShellIntegration();\n\n// Graceful shutdown handler\nprocess.on('SIGTERM', async () => {\n  console.log('Terminating PowerShell processes...');\n  await powerShellIntegration.killAllProcesses();\n});\n\nprocess.on('SIGINT', async () => {\n  console.log('Terminating PowerShell processes...');\n  await powerShellIntegration.killAllProcesses();\n});\n\nmodule.exports = {\n  powerShellIntegration,\n  PowerShellIntegration,\n  PS_CONFIG\n};"